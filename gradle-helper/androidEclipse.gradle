/**
* This file will generate all files necessary to create an android project from
* a gradle project.
**/

import org.gradle.plugins.ide.eclipse.model.SourceFolder

apply plugin: 'eclipse'

eclipse {
	ext.extraSrcDirs = []
    ext.explodeAar = false
    ext.explodeAarList = []
  jdt {
    sourceCompatibility = 1.6
    targetCompatibility = 1.6
  }
  project {
    buildCommand 'com.android.ide.eclipse.adt.ResourceManagerBuilder'
    buildCommand 'com.android.ide.eclipse.adt.PreCompilerBuilder'
    buildCommand 'org.eclipse.jdt.core.javabuilder'
    buildCommand 'com.android.ide.eclipse.adt.ApkBuilder'
    natures 'com.android.ide.eclipse.adt.AndroidNature', 'org.eclipse.jdt.core.javanature'
  }
  classpath {
    defaultOutputDir = file('bin/eclipse/classes')
    containers.clear() //remove default container set (will add JRE otherwise)
    containers.add('com.android.ide.eclipse.adt.ANDROID_FRAMEWORK')
    containers.add('com.android.ide.eclipse.adt.LIBRARIES')

    //add the compile configuration. This is not done by the android plugin
    plusConfigurations += [configurations.compile]
    plusConfigurations += [configurations.androidTestCompile]

    file {
      // Add all necessary entries
      beforeMerged { classpath ->
        classpath.entries.add(new SourceFolder("src", null))
        if (file('aidl').exists()) {
          def aidl = new SourceFolder("aidl", null)
          aidl.includes.add '*.aidl'
          classpath.entries.add(aidl)
        }
        if (file('instrumentTest/java').exists()) {
            classpath.entries.add(new SourceFolder("instrumentTest/java", null))
        }
        if (file('uiTest/java').exists()) {
            classpath.entries.add(new SourceFolder("uiTest/java", null))
        }
        file("gen").mkdir()
        classpath.entries.add(new SourceFolder("gen", null))
		extraSrcDirs.each {
        	classpath.entries.add(new SourceFolder(it, null))
		}
      }

      //Ignore eclipse warnings in the gen folder
      withXml { provider -> 
        provider.asNode().findAll { it.@path.contains("gen") }.each {
          it.appendNode('attributes').appendNode('attribute', [name: 'ignore_optional_problems', value:'true'])
        }
        provider.asNode().findAll { it.@path.endsWith("aar") }.each {
            //extract aar files in order for eclipse to be able to use them -- don't do it anymore since res folder and other stuff will be missing
            File file = new File(it.@path)
            if (explodeAar || explodeAarList.contains(file.name)) {
                logger.info("extrating aar ${file} for eclipse")
                def toDir = "${buildDir}/exploded_bundles/${file.name}"
                copy {
                    from zipTree(file)
                    into toDir
                    include "classes.jar"
                }
                it.@path = "${toDir}/classes.jar"
            }
            else {
                logger.warn("Found aar in classpath, since eclipse can't handle this you'll have to add it as a project dependency manually (${file.name})")
            }
        }
      }
    }
  }
}

task(eclipseProjectProperties) {
    ext.extraProps = new Properties();
    doLast {
        // Let's first merge the existing configuration
        Properties props = new Properties()
        def propfile = file('project.properties')
        if (propfile.exists()) {
          props.load(new FileInputStream(propfile))
        }
        ConfigObject config = new ConfigSlurper().parse(props)
        
        
        // Set the values
        config.target = android.compileSdkVersion
        config.android.library = project.ext.has('androidLibrary') && project.ext.androidLibrary
        
        //append extra properties
        config += extraProps
        
        // Write everything to file
        config.toProperties().store(new FileOutputStream(propfile), "Generated by androidEclipse.gradle")
    }
}

tasks.eclipse.dependsOn(eclipseProjectProperties)
/*Clean everything instead only the eclipse files*/
tasks.cleanEclipse.dependsOn(clean)
